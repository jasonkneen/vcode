// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

// Preload types
interface ThemeModeContext {
  toggle: () => Promise<boolean>;
  dark: () => Promise<void>;
  light: () => Promise<void>;
  system: () => Promise<boolean>;
  current: () => Promise<"dark" | "light" | "system">;
}
interface ElectronWindow {
  minimize: () => Promise<void>;
  maximize: () => Promise<void>;
  close: () => Promise<void>;
}

interface SearchResult {
  filePath: string;
  line: number;
  column: number;
  content: string;
  lineContent: string;
}

interface ProjectApi {
  openFolder: (folderPath?: string) => Promise<void>;
  getCurrentProject: () => Promise<string | null>; 
  setCurrentProject: (projectPath: string) => Promise<void>;
  openFile: (filePath: string) => Promise<{ content: string; path: string }>;
  saveFile: (filePath: string, content: string) => Promise<void>;
  createFile: (filePath: string, content?: string) => Promise<void>;
  createFolder: (folderPath: string) => Promise<void>;
  deleteFile: (filePath: string) => Promise<void>;
  deleteFolder: (folderPath: string) => Promise<void>;
  renameFile: (oldPath: string, newPath: string) => Promise<void>;
  renameFolder: (oldPath: string, newPath: string) => Promise<void>;
  getFileStats: (filePath: string) => Promise<{
    size: number;
    createdAt: Date;
    modifiedAt: Date;
  }>;
  getDirectoryTree: (
    rootPath: string,
    options?: { depth?: number; includeFiles?: boolean } 
  ) => Promise<any>;
  watchFileChanges: (filePath: string) => Promise<void>;
  unwatchFileChanges: (filePath: string) => Promise<void>;
  searchFiles: (
    query: string,
    rootPath?: string,
    options?: { includePatterns?: string[]; excludePatterns?: string[] }
  ) => Promise<string[]>;
  searchInFiles: (
    query: string,
    rootPath?: string,
    options?: { filePatterns?: string[]; excludePatterns?: string[] }
  ) => Promise<SearchResult[]>;
  getRecentProjects: () => Promise<string[]>;
  addRecentProject: (projectPath: string, projectName?: string) => Promise<void>;
  removeRecentProject: (projectPath: string) => Promise<void>;
  setLastOpenedProject: (projectPath: string) => Promise<void>;
  getLastOpenedProject: () => Promise<string | null>;
}

interface AI {
  sendMessage: (payload: { messages: import('ai').CoreMessage[], requestId: string }) => Promise<{ success: boolean, requestId: string }>;
  onStreamChunk: (callback: (data: { requestId: string, chunk: Uint8Array }) => void) => void;
  onStreamEnd: (callback: (data: { requestId: string }) => void) => void;
  onStreamError: (callback: (data: { requestId: string, error: string }) => void) => void;
  removeAllListeners: () => void;
}

interface MapBuilderAI {
  sendMessage: (payload: { messages: import('ai').CoreMessage[], requestId: string }) => Promise<{ success: boolean, requestId: string }>;
  onStreamChunk: (callback: (data: { requestId: string, chunk: Uint8Array }) => void) => void;
  onStreamEnd: (callback: (data: { requestId: string }) => void) => void;
  onStreamError: (callback: (data: { requestId: string, error: string }) => void) => void;
  removeAllListeners: () => void;
}

interface SettingsApi {
  // Regular settings
  get: <T = any>(key: string) => Promise<T | undefined>;
  set: (key: string, value: any) => Promise<boolean>;
  getAll: () => Promise<any>;
  reset: () => Promise<boolean>;
  export: () => Promise<string>;
  import: (settingsJson: string) => Promise<boolean>;

  // Secure settings (API keys, tokens, etc.)
  getSecure: (key: string) => Promise<string | undefined>;
  setSecure: (key: string, value: string) => Promise<boolean>;
  deleteSecure: (key: string) => Promise<boolean>;
  listSecureKeys: () => Promise<string[]>;
}

interface TerminalApi {
  create: (options?: { cwd?: string; title?: string }) => Promise<{ id: string; title: string; cwd: string; pid: number }>;
  write: (terminalId: string, data: string, callback?: (result: string, exitCode: number) => void) => Promise<boolean>;
  resize: (terminalId: string, cols: number, rows: number) => Promise<boolean>;
  kill: (terminalId: string) => Promise<boolean>;
  killAll: () => Promise<boolean>;
  list: () => Promise<{ id: string; title: string; cwd: string; pid: number }[]>;
  onData: (callback: (data: { terminalId: string; data: string }) => void) => () => void;
  onExit: (callback: (data: { terminalId: string; exitCode: number }) => void) => () => void;
  onError: (callback: (data: { terminalId: string; error: string }) => void) => () => void;
  onCommandResult: (callback: (data: { terminalId: string; commandId: string; result: string; exitCode: number }) => void) => () => void;
  removeAllListeners: () => void;
}

interface ShellApi {
  showItemInFolder: (filePath: string) => Promise<void>;
  openExternal: (url: string) => Promise<void>;
}

interface IndexApi {
  buildIndex: (options: {
    projectPath: string;
    excludePatterns?: string[];
    includePatterns?: string[];
    chunkSize?: number;
    chunkOverlap?: number;
  }) => Promise<{ success: boolean }>;
  search: (query: string, limit?: number) => Promise<{
    filePath: string;
    content: string;
    score: number;
    lineNumber?: number;
    snippet?: string;
  }[]>;
  getStatus: () => Promise<{ isBuilt: boolean; projectPath?: string; lastUpdated?: Date }>;
  getStats: () => Promise<{
    totalFiles: number;
    totalChunks: number;
    indexSize: number;
    lastUpdated: Date;
  } | null>;
  clearIndex: () => Promise<{ success: boolean }>;
  updateFile: (filePath: string) => Promise<{ success: boolean }>;
  removeFile: (filePath: string) => Promise<{ success: boolean }>;
  onProgress: (callback: (data: { progress: number; currentFile?: string; message?: string }) => void) => void;
  onError: (callback: (data: { error: string; filePath?: string }) => void) => void;
  removeAllListeners: () => void;
}

interface TypeScriptLSPApi {
  initialize: (projectPath: string) => Promise<{ success: boolean; error?: string }>;
  didOpen: (params: {
    uri: string;
    languageId: string;
    version: number;
    text: string;
  }) => Promise<{ success: boolean; error?: string }>;
  didChange: (params: {
    uri: string;
    version: number;
    changes: any[];
  }) => Promise<{ success: boolean; error?: string }>;
  didClose: (uri: string) => Promise<{ success: boolean; error?: string }>;
  completion: (params: {
    uri: string;
    position: { line: number; character: number };
  }) => Promise<{ success: boolean; result?: any; error?: string }>;
  hover: (params: {
    uri: string;
    position: { line: number; character: number };
  }) => Promise<{ success: boolean; result?: any; error?: string }>;
  definition: (params: {
    uri: string;
    position: { line: number; character: number };
  }) => Promise<{ success: boolean; result?: any; error?: string }>;
  references: (params: {
    uri: string;
    position: { line: number; character: number };
  }) => Promise<{ success: boolean; result?: any; error?: string }>;
  signatureHelp: (params: {
    uri: string;
    position: { line: number; character: number };
  }) => Promise<{ success: boolean; result?: any; error?: string }>;
  status: () => Promise<{ isRunning: boolean }>;
}

interface ElectronAPI {
  typescriptLSP: TypeScriptLSPApi;
  onTypescriptLSPNotification: (callback: (notification: any) => void) => void;
}

declare interface Window {
  themeMode: ThemeModeContext;
  electronWindow: ElectronWindow;
  projectApi: ProjectApi;
  ai: AI;
  mapBuilderAI: MapBuilderAI;
  settingsApi: SettingsApi;
  terminalApi: TerminalApi;
  shellApi: ShellApi;
  indexApi: IndexApi;
  electronAPI: ElectronAPI;
}

declare module "@joplin/turndown-plugin-gfm" {
  export const gfm: any;
  // Add other named exports if necessary
}